<!DOCTYPE html>
<html>
<head>
<script>
    function fizzbuzz(){
        for(i = 1; i < 100; i++) {
            if((i%3) == 0) {
                console.log("Fizz");
            } else if ((i % 5) == 0) {
                console.log("Buzz");
            } else {
                console.log(i);
            }
        }
    }
    min = (a,b) => {
      if(a<b) {
        return a;
      } else {
        return b;
      }
    }
    function testmin() {
        console.log(min(0, 10));
        // → 0
        console.log(min(0, -10));
        // → -10
    }
   
    isEven = function(x) {
      if(x == 0) {
        return(true);
      } else if(x == 1) {
        return(false);
      } else {
        return(isEven(x-2));
      }
    }
    function testrecurse() {
        console.log(isEven(50));
        // → true
        console.log(isEven(75));
        // → false
        console.log(isEven(10001));
        //console.log(isEven(-1));
    }
    testflatten = function() {
      let arrays = [[1, 2, 3], [4, 5], [6]];
      // Your code here.
      // reduce() is called with two arguments: a callback function, 
      // and an initial value. reduce() then calls that callback function 
      // in a loop multiple times, each time passing it two arguments. 
      // The first argument is the accumulated value, and the second argument is the 
      // next value to be operated on. If the initial value is specified, 
      // then for the first time through the loop, the accumulated value 
      // takes that value, which is why flat is the empty list for the first iteration.
      console.log("2d ",arrays[0][1]);
      myflat = arrays.reduce(
        function(flat, current) {
          console.log("flat ",flat," current ",current);
          return flat.concat(current);
        }, []);
      console.log(myflat);
      arrays = [1, 2, 3, 4, 5,6];
      myflat = arrays.reduce(
        function(flat, current) {
          console.log("flat ",flat," current ",current);
          return flat + current;
        }, 0);
      console.log(myflat);
// → [1, 2, 3, 4, 5, 6]
    }
    testevery = () => {
      function every(array, test) {
        // Your code here.
        console.log(test);
        for (let element of array) {
          if (test(element) === false) {
            return false;
          }
        }
        return true;
        // Demorgans Theorem (A && B) === ! (!A || !B)
      }
    
      console.log(every([1, 3, 5], n => n < 10));
      // → true
      console.log(every([2, 4, 16], n => n < 10));
      // → false
      console.log(every([], n => n < 10));
      // → true
    }
    testtable = () => {
      const MOUNTAINS = [
        {name: "Kilimanjaro", height: 5895, place: "Tanzania"},
        {name: "Everest", height: 8848, place: "Nepal"},
        {name: "Mount Fuji", height: 3776, place: "Japan"},
        {name: "Vaalserberg", height: 323, place: "Netherlands"},
        {name: "Denali", height: 6168, place: "United States"},
        {name: "Popocatepetl", height: 5465, place: "Mexico"},
        {name: "Mont Blanc", height: 4808, place: "Italy/France"}
      ];

      // Your code here
      let target = document.getElementById("mountains");
      myth = document.createElement("table");
      target.appendChild(myth);
      for(mt in MOUNTAINS) {
        console.log(mt);
        mytr = document.createElement("tr");
        mytr.appendChild(document.createTextNode(MOUNTAINS[mt].name));
    	  myth.appendChild(mytr);
      }
    }
</script>
</head>
<body>
<p onclick="fizzbuzz()">FizzBuzz</p>   
<p onclick="testmin()">min</p>
<p onclick="testrecurse()">recurse</p>
<p onclick="testflatten()">flatten</p>
<p onclick="testevery()">every</p>
<p onclick="testtable()">table</p>
<h1>Mountains</h1>

<div id="mountains"></div>
</body>
</html>